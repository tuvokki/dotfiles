#host specific settings. These will not change when the zshrc is globally updated
export EDITOR=vim
export LANGUAGE=en_US.UTF-8
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8

# set PATH so it includes user's private bin if it exists
if [ -d ~/bin ] ; then
      PATH=~/bin:$PATH
fi
export DEVELOPER_ROOT="/home/wouter/development"
export GRADLE_HOME="$DEVELOPER_ROOT/gradle"
export PATH="$PATH:$GRADLE_HOME/bin"

# set lush prompt with color and stuff
#prompt elite2 magenta yellow
# the minimalistic prompt
#prompt suse
# the minimalistic of all minimalistic prompts: off ....
prompt off

#but with a little more than nothing in the $PROMPT:
PS1='[%l]%20<..<%~%# '
#PS1='%20<..<%~%# '
# # I like to have a different PS2 prompt but its default functionality is nice ;)
PS2='[%?]%B%_>%b'
#PS2='[%m]%B%_>%b'
#PS3='[] '
#PS4='[=] '
#examples:
# [USERNAME@HOSTNAME PWD(WITH A ~ FOR HOME)]%(WITH A # FOR SUPERUSER)
# PS1='%B[%n@%m %~]%#%b '

# Watch for my friends
# #watch=( $(<~/.friends) )       # watch for people in .friends file
watch=(notme)                     # watch for everybody but me
LOGCHECK=3                        # check every -300s=5 min- 3 sec for login/logout activity
WATCHFMT='%n %a %l from %m at %t.'

#getscreen

## functions for displaying neat stuff in *term title
case $TERM in
  *xterm*|rxvt|(dt|k|E)term)
  ## display user@host and full dir in *term title
  precmd () {
    #print -Pn  "\033]0;%n@%m %~\007"
    print -Pn "\033]0;%n@%m%#  %~ %l  %w :: %T\a" ## or use this
  }
  ## display user@host and name of current process in *term title
  preexec () {
    print -Pn "\033]0;%n@%m <$1> %~\007"
    #print -Pn "\033]0;%n@%m%#  <$1>  %~ %l  %w :: %T\a" ## or use this
  }
  ;;
esac

LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;90:su=01;35:sg=01;35:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:*.txt=01;35:*.xml=01;35:*.sh=01;34:*.out=01;37:*.log=01;90:';

export LS_COLORS

# set the current working directory into the title bar of an xterm
function chpwd {
  print -n "$(print -D $HOSTNAME $PWD)"
}

#Get a screen if not in a a screen
function getscreen() {
  #if [[ $TERM != 'screen' || $TERM != 'linux' ]] ; then
  if [[ $TERM != 'screen' && $TERM != 'linux' ]] ; then
    exec screen -RR
  fi
}

#Delete all networked files generated by AFP
function sweep()
{
  if [ -d :2eTemporaryItems ]; then
    rm -rf :2eTemporaryItems
  fi
  find . -name ".AppleDouble" -exec rm -rf {} \;
  find . -name "\:2e*" -exec rm -rf {} \;
}

#get my current external ip
function whatsmyip()
{
 export EXTERNALIP=`curl -s checkip.dyndns.org|sed -e 's/.*Current IP Address: //' -e 's/<.*$//'`
 echo $EXTERNALIP
}

#set completion for the screen command.
compctl -j -P '%' + -s '`ps x | grep SCREEN | grep -v grep | cut -c1-5`' screen

# Completion will only occur for directories and symbolic links that point at directories.
# The trailing "D" qualifier is used to turn on the globdots option temporarily.
# This means you can complete things like ~/.netscape.
compctl -g '*(-/D)' cd

# Setting up an array with a list of things you want to complete is easy. Here, ftp only completes the hosts listed in the array.
ftphosts=(ftp.{free,net,open}bsd.org) ; compctl -k ftphosts ftp
#
# This simply says that when completing stuff after a command, only choose from files that end in *.something
compctl -g '*.ps' ghostview
compctl -g '*.torrent' btdl
compctl -g '*.pdf' xpdf acroread kpdf

#set up some completion on suspended jobs
compctl -z -P '%' bg
compctl -j -P '%' fg jobs disown
# kill takes signal names as the first argument after -, but job names after %
# or PIDs as a last resort
compctl -j -P '%' + -s '`ps x | tail +2 | cut -c1-5`' + x 's[-] p[1]' -k "($signals[1,-3])" -- kill

# scp: match users, hosts and files initially.  Match files after a :, or hosts
# after an @.  If one argument contains a : then the other matches files only.
# Not quite perfect; compctl just isn't up to it yet.
compctl -u -k hosts -f -x 'n[1,:]' -f - 'n[1,@]' -k hosts -S ':' - \
  'p[1] W[2,*:*]' -f - 'p[1] W[2,*?*]' -u -k hosts -S ':' - \
  'p[2] W[1,*:*]' -f - 'p[2] W[1,*?*]' -u -k hosts -S ':' -- scp
